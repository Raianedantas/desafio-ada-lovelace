"""Desafio Data Wrangling e Pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FSDOFCxGh_gZTQhxYeAZt9RfPZTdb5H8
"""

import pandas as pd
import sqlite3

df = pd.read_csv('/content/sample_data/vendas.csv', sep = ",")
# O Jupiter, deleta o arquivo do notebook, para ter segurança ao rodar o código, o arquivo está disponivel no
# repositorio do projeto - https://github.com/Raianedantas/desafio-ada-lovelace/blob/main/schema.sql

df.head()

"""# 2. Tranformação (T)

*   **Padronizar a coluna de data**

Lógica utilizada na resolução do exercício:

Primeiro verificamos que data_venda estava como object, ou seja, texto. Vamos mudar isso para que ele fique no formato data com o comando pd.to_datetime().

Depois verificamos que tem dois tipos de formatos dentro das datas, uma que utiliza '/' e outro que utiliza '-', se colocarmos o comando sem especificar o formato desejado alguns vão ficar como 'NaT'. Para corrigir isso vamos colocar dentro do comando format='mixed'.
"""

#verificar qual o formato de data_venda
print(df.dtypes)

#transformar de texto para data
df['data_venda'] = pd.to_datetime(df['data_venda'], format='mixed', errors='coerce')

"""*   **Substituir valores nulos por "Não informado"**

Lógica utilizada na resolução do exercício:

Queremos transformar todos os valores nulos (NaN) em 'Não informado'. No entanto, essa substituição só deve ser feita em colunas do tipo texto (object), para não corromper colunas numéricas (que deixariam de ser números).

Para isso, primeiro selecionamos apenas as colunas do tipo texto usando o comando df.select_dtypes(include=['object']).columns.

Depois disso, aplicamos o comando .fillna('Não informado') apenas nesse conjunto de colunas selecionadas, substituindo os valores vazios por 'Não informado'.
"""

#Seleciona as colunas do formato texto
colunas_texto = df.select_dtypes(include=['object']).columns

#Aplica .fillna() nas colunas selecionadas
df[colunas_texto] = df[colunas_texto].fillna('Não informado')

"""- **Corrigir quantidade para ser sempre número inteiro.**

Lógica utilizada na resolução do exercício:

Primeiro verificamos quais eram os valores presentes na coluna Quantidade, para saber quais seriam os valores que precisariam ser substituídos.

Assim, criamos um dicionário para mapear a conversão dos valores e usá-lo no comando **replace()** para fazer as substituições.

Em seguida, a conversão para tipo númerico foi feita utilizando o comando da biblioteca pandas **pd.to_numeric** com o argumento **errors = 'coerce'** para que se algum valor na coluna não pudesse ser convertido, ele fosse substituído por NaN (Not a Number), em vez de gerar um erro; além de acrescentar o **astype(int)** para garantir que todos os valores da coluna sejam do tipo inteiro
"""

# Ver quais valores únicos existem na coluna quantidade
print(df['quantidade'].unique())

# Dicionário de conversão de palavras para números
mapa_numeros = {
    'um': 1, 'dois': 2, 'três': 3, 'quatro': 4, 'cinco': 5
}

#Substitui palavras por números
df['quantidade'] = df['quantidade'].replace(mapa_numeros)

# Converte para número inteiro
df['quantidade'] = pd.to_numeric(df['quantidade'], errors='coerce').astype(int)

df

"""*   **Remover ou corrigir preços negativos.**

Lógica utilizada para resolução do exercício:

Utilizando **pd.api.types.is_numeric_dtype**, uma função do Pandas para verificar se a coluna é numérica ou não, criamos uma condição para adicionar na lista **colunas_com_negativos**, as colunas que apresentassem valores numéricos menores que 0.
"""

colunas_com_negativos = []

for coluna in df.columns:
    # verifica se a coluna é numérica
    if pd.api.types.is_numeric_dtype(df[coluna]):
        # verifica se algum valor é negativo
        if (df[coluna] < 0).any():
            colunas_com_negativos.append(coluna)

# mostra as colunas que têm valores negativos
print("Colunas com negativos:", colunas_com_negativos)

# DataFrame só com essas colunas
df_filtrado = df[colunas_com_negativos]
print(df_filtrado)

"""Sabendo qual a coluna que possuia os valores negativos, utilizamos o método **abs()** para retornar o valor absoluto dos valores que estavam negativos. E, por fim, verificamos se algum valor ainda estava negativo e tivemos **False** como saída, alcançando nosso objetivo."""

df['preco_unitario'] = df['preco_unitario'].abs()

print((df['preco_unitario'] < 0).any())

"""*   **Criar uma nova coluna valor_total = quantidade * preco_unitario.**

Lógica utilizada para resolução do exercício

Realizamos o cálculo da quantidade * preço unitário, adicionando a nova coluna de valor total para esse resultado.
"""

df['valor_total'] = df['quantidade'] * df['preco_unitario']

df.head()

import sqlite3

conn = sqlite3.connect('vendas.db')

df.to_sql('tb_vendas', conn, if_exists='replace', index=False)

conn.close()

print("Dados carregados com sucesso em 'vendas.db', na tabela 'tb_vendas'.")

"""Desafio Extra"""

clientes_unicos = df['cliente'].unique()

df_clientes = pd.DataFrame(clientes_unicos, columns=['nome_cliente'])
df_clientes['id_cliente'] = range(1, len(df_clientes) + 1)

df_clientes = df_clientes[['id_cliente', 'nome_cliente']]
print("DataFrame 'df_clientes' criado.")

mapa_ids_cliente = df_clientes.set_index('nome_cliente')['id_cliente']

df['id_cliente'] = df['cliente'].map(mapa_ids_cliente)

colunas_tb_vendas = [
    'data_venda',
    'produto',
    'quantidade',
    'preco_unitario',
    'categoria',
    'valor_total', # Coluna que você criou em [42]
    'id_cliente'   # A Chave Estrangeira (FK)
]
df_vendas_final = df[colunas_tb_vendas]
print("DataFrame 'df_vendas_final' (com FK) criado.")

ARQUIVO_DB = 'vendas.db'

conn = sqlite3.connect(ARQUIVO_DB)

df_clientes.to_sql('tb_clientes', conn, if_exists='replace', index=False)
print("Tabela 'tb_clientes' salva com sucesso.")

df_vendas_final.to_sql('tb_vendas', conn, if_exists='replace', index=False)
print("Tabela 'tb_vendas' salva com sucesso.")

print(f"Dados carregados e normalizados em '{ARQUIVO_DB}'.")

query_sql = """
SELECT
    categoria,
    SUM(valor_total) AS total_vendido
FROM
    tb_vendas
GROUP BY
    categoria
ORDER BY
    total_vendido DESC;
"""

df_resultados = pd.read_sql_query(query_sql, conn)

print(df_resultados)

conn.close()
print("\nDesafio Extra concluído com sucesso!")
